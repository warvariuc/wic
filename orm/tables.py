import inspect
import re
import orm


class TableType(type):
    '''Metaclass for all tables.'''
    
    def __new__(cls, name, bases, attrs):
        newClass = type.__new__(cls, name, bases, attrs)
        
        if 'Table' in globals(): # only Table subclasses. if Table is not defined - __new__ is called for it
            for fieldName, field in list(inspect.getmembers(newClass)):
                if isinstance(field, orm.fields.Field):
                    if not fieldName.islower():
                        raise Exception('Field names must be lowercase. Field `{}` in Table `{}`'.format(fieldName, name))
                    if fieldName.startswith('_'):
                        raise Exception('Field names can not start with `_`. Field `{}` in Table `{}`'.format(fieldName, name))
                    field = field.__class__(*field._initArgs, **field._initKwargs) # recreate the field - to handle correctly inheritance
                    field._init(fieldName, newClass, *field._initArgs, **field._initKwargs)
                    setattr(newClass, fieldName, field) # each class
                    del field._initArgs, field._initKwargs
        
        return newClass


class Table(metaclass=TableType):
    '''Base class for all tables. Class attributes - the fields. 
    Instance attributes with the same names - the values for the corresponding fields.'''
    id = orm.IdField() # this field is present in all tables
    #__indexes = DbIndex(Table.id, primary = True)

    def __init__(self, **kwargs):
        '''Initialize a new record in this table.'''
        self.dbAdapter = kwargs.pop('db', orm.defaultDbAdapter)
        
        # make values for fields 
        for fieldName, field in inspect.getmembers(self.__class__):
            if isinstance(field, orm.fields.Field):
                fieldValue = field._cast(kwargs.pop(fieldName, field.defaultValue))
                setattr(self, fieldName, fieldValue)
            
    def delete(self):
        (self.__class__.id == self.id).delete(self.dbAdapter)




regex_quotes = re.compile("'[^']*'")
def xorify(orderby):
    if not orderby:
        return None
    orderby2 = orderby[0]
    for item in orderby[1:]:
        orderby2 = orderby2 | item
    return orderby2
def raw(s): return Expression(None, s)

class Set(object):

    """
    a Set represents a set of records in the database,
    the records are identified by the query=Query(...) object.
    normally the Set is generated by DAL.__call__(Query(...))

    given a set, for example
       set = db(db.users.name=='Max')
    you can:
       set.update(db.users.name='Massimo')
       set.delete() # all elements in the set
       set.select(orderby=db.users.id, groupby=db.users.name, limitby=(0,10))
    and take subsets:
       subset = set(db.users.id<5)
    """

    def __init__(self, db, query):
        self.db = db
        self.query = query

    def __call__(self, query):
        if isinstance(query, Table):
            query = query._id > 0
        elif isinstance(query, str):
            query = raw(query)
        elif isinstance(query, Field):
            query = query != None
        if self.query:
            return Set(self.db, self.query & query)
        else:
            return Set(self.db, query)

    def _count(self, distinct=None):
        return self.db._adapter._count(self.query, distinct)

    def _select(self, *fields, **attributes):
        return self.db._adapter._select(self.query, fields, attributes)

    def _delete(self):
        tablename = self.db._adapter.get_table(self.query)
        return self.db._adapter._delete(tablename, self.query)

    def _update(self, **update_fields):
        tablename = self.db._adapter.get_table(self.query)
        fields = self.db[tablename]._listify(update_fields, update=True)
        return self.db._adapter._update(tablename, self.query, fields)

    def isempty(self):
        return not self.select(limitby=(0, 1))

    def count(self, distinct=None):
        return self.db._adapter.count(self.query, distinct)

    def select(self, *fields, **attributes):
        return self.db._adapter.select(self.query, fields, attributes)

    def delete(self):
        tablename = self.db._adapter.get_table(self.query)
        self.delete_uploaded_files()
        return self.db._adapter.delete(tablename, self.query)

    def update(self, **update_fields):
        tablename = self.db._adapter.get_table(self.query)
        fields = self.db[tablename]._listify(update_fields, update=True)
        if not fields:
            raise SyntaxError("No fields to update")
        self.delete_uploaded_files(update_fields)
        return self.db._adapter.update(tablename, self.query, fields)

    def validate_and_update(self, **update_fields):
        tablename = self.db._adapter.get_table(self.query)
        response = Row()
        response.errors = self.db[tablename]._validate(**update_fields)
        fields = self.db[tablename]._listify(update_fields, update=True)
        if not fields:
            raise SyntaxError("No fields to update")
        self.delete_uploaded_files(update_fields)
        if not response.errors:
            response.updated = self.db._adapter.update(tablename, self.query, fields)
        else:
            response.updated = None
        return response
