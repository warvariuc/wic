import sys

from PyQt5 import QtGui, QtCore, QtWidgets
import peewee

from wic.datetime import DateTime

from wic import forms, widgets, menus
import wic

from .catalog_view_model import CatalogViewModel, CatalogModel, DefaultSectionSizeRole


class CatalogItemForm(forms.Form):
    """Form of a catalog item.
    """
    _ui_file_path = None  # autogenerated by default
    _form_title = 'Catalog item'
    _icon_path = ':/icons/fugue/card-address.png'
    _catalog_item = None
    _spacing: int = None

    def __init__(self, catalog_item, **kwargs):
        assert isinstance(catalog_item, CatalogModel), \
            'Must be a catalog item (CatalogModel instance)'
        super().__init__(_catalog_item=catalog_item, **kwargs)

    def setupUi(self):
        """Initial setting up of the form. Reimplemented.
        Dynamically create form fields, if no ui file is supplied. 
        Fill form fields with data from DB.
        """
        self._form_title = '%s item' % self._catalog_item.__class__
        if not self._ui_file_path:  # automatically generated form
            self.create_widgets()
        self.setup_widgets()
        super().setupUi()
        self.fill_form_from_item()

    def create_widgets(self):
        """Automatically create on the form widgets and labels for each catalog model field.
        """
        form_layout = QtWidgets.QFormLayout(self)
        if self._spacing is not None:
            form_layout.setSpacing(self._spacing)
        for field in self._catalog_item._meta.sorted_fields:
            field_name = field.name
            assert not hasattr(self, field_name), \
                'Form already has attribute with name `%s`' % field_name
            widget, label = self.create_widget_for_field(field)
            widget.setObjectName(field_name)
            setattr(self, field_name, widget)
            #label.setObjectName('label_' + fieldName)
            setattr(self, 'label_' + field_name, label)
            label.setBuddy(widget)
            form_layout.addRow(label, widget)

        # FIXME: it's too implicit that there is should be a button box called button_box on hte form
        self.button_box = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Reset |
            QtWidgets.QDialogButtonBox.Save |
            QtWidgets.QDialogButtonBox.Cancel)
        self.button_box.setObjectName('buttonBox')
        form_layout.addRow(self.button_box)
        self.form_layout = form_layout

    def setup_widgets(self):
        """Set up widgets which are mapped to catalog model fields. 
        Connect button box signals to the corresponding handlers.
        """
        for field in self._catalog_item._meta.sorted_fields:
            widget = getattr(self, field.name, None)
            if widget:
                self.setup_widget_for_field(widget, field)

    def on_reset(self):
        self.fill_form_from_item()

    def fill_form_from_item(self):
        """Automatically fill the form fields using the values from the catalog item fields.
        """
        catalog_item = self._catalog_item
        for field in catalog_item._meta.sorted_fields:
            field_name = field.name
            widget = getattr(self, field_name, None)
            if widget:
                field_value = getattr(catalog_item, field.name)
                forms.set_value(widget, field_value)

    def fill_item_from_form(self):
        """Automatically fill the item field values from the corresponding form widgets.
        """
        catalog_item = self._catalog_item
        for field in catalog_item._meta.sorted_fields:
            field_name = field.name
            widget = getattr(self, field_name, None)
            if widget:
                field_value = forms.get_value(widget)
                if field.name == 'id' and not field_value:
                    # if nothing is entered into Id field - treat it as NULL
                    field_value = None
                elif isinstance(field, peewee.DateTimeField):
                    if any(char.isdigit() for char in field_value):
                        field_value = DateTime.strptime(field_value, '%Y-%m-%d %H:%M:%S.%f')
                    else:
                        field_value = None
                setattr(catalog_item, field_name, field_value)

    def on_save(self):
        """Called when save button is pressed.
        """
        catalog_item = self._catalog_item
        self.fill_item_from_form()
        catalog_item.save()

        # update item id and timestamp on the form
        id_widget = getattr(self, 'id', None)
        if id_widget:
            forms.set_value(id_widget, catalog_item.id)
        timestamp_widget = getattr(self, 'timestamp', None)
        if timestamp_widget:
            forms.set_value(timestamp_widget, catalog_item.timestamp)
        print('save!')

    def create_widget_for_field(self, field):
        """Create widget and label for the given model field.

        Args:
            field: model field

        Returns:
            tuple (QWidget, QLabel): the widget and its label
        """
        assert isinstance(field, peewee.Field)
        label = field.verbose_name or field.name
        if field.name == 'id':
            widget = QtWidgets.QLineEdit()
        elif isinstance(field, (peewee.CharField, peewee.IntegerField, peewee.DateTimeField)):
            widget = QtWidgets.QLineEdit()
        elif isinstance(field, peewee.DecimalField):
            widget = widgets.DecimalEdit()
        elif isinstance(field, peewee.DateField):
            widget = widgets.DateEdit()
        elif isinstance(field, peewee.BooleanField):
            widget = QtWidgets.QCheckBox(field.verbose_name)
            # label = ''
        elif isinstance(field, peewee.TextField):
            widget = QtWidgets.QPlainTextEdit()
        elif isinstance(field, peewee.ForeignKeyField):
            widget = widgets.CatalogItemWidget()
        else:
            raise Exception(f'Could not create a widget for field `{field}`')
        return widget, QtWidgets.QLabel(label)

    def setup_widget_for_field(self, widget, field):
        """Set up a widget which corresponds to a model field -- only the details related to data
        entering to appearance. The widget might be autocreated or one from a *.ui file.
        """
        assert isinstance(field, peewee.Field) and isinstance(widget, QtWidgets.QWidget)
        if field.name == 'id':
            widget.setValidator(QtGui.QIntValidator())
        elif isinstance(field, peewee.CharField):
            if isinstance(widget, QtWidgets.QLineEdit):
                widget.setMaxLength(field.max_length)
        elif isinstance(field, peewee.DateTimeField):
            if isinstance(widget, QtWidgets.QLineEdit):
                widget.setInputMask('9999-99-99 99:99:99.999999')
        elif isinstance(field, peewee.DecimalField):
            if isinstance(widget, widgets.DecimalEdit):
                widget.maxDigits = field.column.precision
                widget.fractionDigits = field.column.scale
        elif isinstance(field, peewee.ForeignKeyField):
            if isinstance(widget, widgets.CatalogItemWidget):
                catalog_model = field.rel_model
                widget.setModel(catalog_model.__module__ + '.' + catalog_model.__name__)


class CatalogForm(forms.Form):
    """Form with a list of catalog items.
    """
    _ui_file_path = None
    _form_title = 'Catalog'
    _icon_path = ':/icons/fugue/cards-address.png'
    _is_toolbar_visible = True

    _catalog_model = None
    # which columns to show in form 'field_name1+100,100 field2,+field3 250,field4 -,field5'
    _columns = None
    # you can override this to customize visual appearance
    _view_model = CatalogViewModel

    itemSelected = QtCore.pyqtSignal(CatalogModel)
    # 0: selection causes opening item form,
    # 1: send itemSelected signal and close the form,
    # 2: send signal but do not close the form (for multiple selection)
    _type = 0

    def __init__(self, catalog_model, type=0, **kwargs):
        super().__init__(_catalog_model=catalog_model, _type=type, **kwargs)

    def setupUi(self):
        """Initial setting up of the form.
        Dynamically create form widgets, if no ui file is supplied. 
        Fill form fields with data from DB.
        """
        self._form_title = f'{self._catalog_model} catalog'
        if not self._ui_file_path:
            # automatically generated form
            self.create_widgets()
        super().setupUi()
        self.toolbar.setVisible(self._is_toolbar_visible)
        self.table_view.setFocus()
        # self.tableView.resizeColumnsToContents() - too slow - requests all the data from model

    def create_widgets(self):
        """Automatically create widgets on the form.
        """
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(2)

        self.toolbar = QtWidgets.QToolBar()
        self.setup_toolbar(self.toolbar)
        layout.addWidget(self.toolbar)

        self.table_view = QtWidgets.QTableView()
        self.setup_table_view(self.table_view)
        layout.addWidget(self.table_view)

        self.button_box = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Close)
        layout.addWidget(self.button_box) # add standard button box at the bottom

        self.layout = layout

    def setup_toolbar(self, toolbar):
        assert isinstance(toolbar, QtWidgets.QToolBar)
        menu = wic.Bunch()
        menu.create_item = menus.create_action(
            toolbar, 'Create new item', self.create_item, 'Insert', ':/icons/fugue/plus.png')
        menu.edit_item = menus.create_action(
            toolbar, 'Edit selected item', self.edit_item, 'Enter', ':/icons/fugue/pencil.png')
        menu.delete_item = menus.create_action(
            toolbar, 'Delete selected item', self.delete_item, 'Delete', ':/icons/fugue/cross.png')
        menus.add_actions_to_menu(toolbar, menu.create_item, menu.edit_item, menu.delete_item)
        toolbar.setIconSize(QtCore.QSize(16, 16))
        self.menu = menu

    def setup_table_view(self, table_view):
        assert isinstance(table_view, QtWidgets.QTableView)

        # create catalog view model
        catalog_view_model = self._view_model(self._catalog_model)

        table_view.setSelectionBehavior(table_view.SelectItems)
        table_view.setSelectionMode(table_view.SingleSelection)
        # self.tableView.verticalHeader().hide()
        table_view.verticalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
        # rowHeight = QtGui.QFontMetrics(QtGui.QApplication.font()).height() + 4 # font height and some spare pixels
        rowHeight = catalog_view_model.headerData(0, QtCore.Qt.Vertical, DefaultSectionSizeRole)
        table_view.verticalHeader().setDefaultSectionSize(rowHeight)
        # tableView.setIconSize(QtCore.QSize(16, 16))
        # tableView.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents) # very slow - it queries all items
        # the last visible section in the header takes up all the available space
        table_view.horizontalHeader().setStretchLastSection(True)
        table_view.setGridStyle(QtCore.Qt.DotLine)

        table_view.installEventFilter(self)
        table_view.doubleClicked.connect(self.menu.edit_item.trigger)
        table_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)

        table_view.setModel(catalog_view_model)

        # signals
        table_view.customContextMenuRequested.connect(self.onTableViewContextMenuRequested)
        table_view.selectionModel().selectionChanged.connect(self.onSelectionChanged)
        catalog_view_model.modelAboutToBeReset.connect(self.onModelAboutToBeReset)
        catalog_view_model.modelReset.connect(self.onModelReset)
        table_view.verticalScrollBar().valueChanged.connect(self.ensure_selection_visible)
        table_view.horizontalScrollBar().valueChanged.connect(self.ensure_selection_visible)

        table_view.setCurrentIndex(table_view.model().index(0, 0))

    def eventFilter(self, table_view, event):  # target - tableView
        #print('eventFilter', event)
        if event.type() == QtCore.QEvent.KeyPress:
            if event.modifiers() in (QtCore.Qt.NoModifier, QtCore.Qt.KeypadModifier):
                key = event.key()
                if key in (QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return):
                    self.menu.edit_item.trigger()
                    return True
                elif key == QtCore.Qt.Key_End:
                    current_index = table_view.selectionModel().currentIndex()
                    table_view.setCurrentIndex(table_view.model().index(
                        table_view.model().row_count(None) - 1, current_index.column()))
                    return True
                elif key == QtCore.Qt.Key_Home:
                    current_index = table_view.selectionModel().currentIndex()
                    table_view.setCurrentIndex(table_view.model().index(0, current_index.column()))
                    return True
        elif event.type() == QtCore.QEvent.MouseButtonDblClick:
            if event.button() == QtCore.Qt.LeftButton:
                self.menu.edit_item.trigger()
                return True
        elif event.type() == QtCore.QEvent.Wheel:
            # received when scrolling on viewport is on the boundaries
            current_index = table_view.selectionModel().currentIndex()
            row_no = current_index.row() - int(event.angleDelta().y() / 120)
            # to be sure it's not out of boundaries
            row_no = min(max(row_no, 0), table_view.model().rowCount(None) - 1)
            # when scrolling on the boundary - move the selection closer to that boundary
            table_view.setCurrentIndex(table_view.model().index(row_no, current_index.column()))
            return True

        return super().eventFilter(table_view, event) # standard event processing

    def ensure_selection_visible(self, *args):
        """Ensure that selection moves when scrolling - it must be always visible.
        """
        table_view = self.table_view
        current_index = table_view.selectionModel().currentIndex()
        view_rect = table_view.viewport().rect()

        row = _row = current_index.row()
        column = _column = current_index.column()
        top_row = table_view.indexAt(view_rect.topLeft()).row()
        if row < top_row:
            row = top_row
        else:
            row = min(row, table_view.indexAt(view_rect.bottomLeft()).row())
        left_column = table_view.indexAt(view_rect.topLeft()).column()
        if column < left_column:
            column = left_column
        else:
            column = min(column, table_view.indexAt(view_rect.topRight()).column())
        index = table_view.model().index(row, column)
        item_rect = table_view.visualRect(index)
        if item_rect.top() < view_rect.top():
            row += 1
        elif item_rect.bottom() > view_rect.bottom():
            row -= 1
        if item_rect.left() < view_rect.left():
            column += 1
        elif item_rect.right() > view_rect.right():
            column -= 1
        if column != _column or row != _row:
            table_view.setCurrentIndex(table_view.model().index(row, column))

    def onModelAboutToBeReset(self):
        """Remember the selected row when the model is about to be reset.
        """
        current_index = self.table_view.selectionModel().currentIndex()
        self._last_selected_item = (current_index.row(), current_index.column())

    def onModelReset(self):
        """Restore the selected item after the model was reset.
        """
        row_no, col_no = self._last_selected_item
        row_no = min(row_no, self.table_view.model().rowCount(None) - 1)
        col_no = min(col_no, self.table_view.model().columnCount(None) - 1)
        index = self.table_view.model().index(row_no, col_no)
        self.table_view.setCurrentIndex(index)

    def onSelectionChanged(self):
        current_index = self.table_view.selectionModel().currentIndex()
        self.menu.edit_item.setEnabled(current_index.isValid())

    def onTableViewContextMenuRequested(self, coord):
        menu = QtWidgets.QMenu(self.table_view)
        menus.add_actions_to_menu(
            menu, self.menu.create_item, self.menu.edit_item, self.menu.delete_item)
        menu.popup(self.table_view.viewport().mapToGlobal(coord))

    def create_item(self):
        catalog_item = self._catalog_model()
        open_catalog_item_form(catalog_item)

    def edit_item(self):
        current_index = self.table_view.selectionModel().currentIndex()
        catalog_item = self.table_view.model().item(current_index.row())
        if self._type == 0:
            open_catalog_item_form(catalog_item)
        elif self._type == 1:
            # emit signal and close the form
            self.itemSelected.emit(catalog_item)
            self.close()
        else:
            # emit signal but do not close the form
            self.itemSelected.emit(catalog_item)

    def delete_item(self):
        if QtWidgets.QMessageBox.question(
                self, 'Delete', 'Are you sure?',
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel
        ) == QtWidgets.QMessageBox.Yes:
            current_index = self.table_view.selectionModel().currentIndex()
            catalog_item = self.table_view.model().item(current_index.row())
            catalog_item.delete()


def open_catalog_item_form(catalog_item, FormClass=None, **kwargs):
    assert isinstance(catalog_item, CatalogModel), 'Pass a catalog item (CatalogModel instance).'
    if FormClass is None:
        form_module_path = catalog_item.__class__.__module__
        FormClass = getattr(sys.modules[form_module_path], 'Form', None)
        if FormClass is None:
            # if user form not present - take CatalogItemForm with autogenerated widgets
            FormClass = CatalogItemForm
            _ui_file_path = ''
        else:
            _ui_file_path = FormClass._ui_file_path
        kwargs['_ui_file_path'] = _ui_file_path
    kwargs['catalog_item'] = catalog_item

    if not isinstance(FormClass, type) and issubclass(FormClass, CatalogItemForm):
        raise forms.FormNotFoundError('This is not a CatalogItemForm')

    return forms.open_form(FormClass, **kwargs)


def open_catalog_form(catalog_model, db=None, FormClass=None, **kwargs):
    db = db or wic.database
    if isinstance(catalog_model, str):
        catalog_model = wic.get_object_by_path(catalog_model)
    assert issubclass(catalog_model, peewee.Model), 'Pass a model class.'
    # catalog_model.checkTable(db) # before opening the form
    if not FormClass:
        form_module_path = catalog_model.__module__
        FormClass = getattr(sys.modules[form_module_path], 'CatalogForm', CatalogForm)

    assert issubclass(FormClass, CatalogForm), 'This is not a CatalogForm'
    kwargs['catalog_model'] = catalog_model
    kwargs['db'] = db
    return forms.open_form(FormClass, **kwargs)
